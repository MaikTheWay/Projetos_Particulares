# -*- coding: utf-8 -*-
"""MaratonaChristopher.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V9j7P35lzOHScCWk78nivc4h6FWRkp5V
"""

import numpy as np

#                    Cifra de Vigenère
#                le chiffre indéchiffrable
# Marcos Alcino

class Vigenere:
  
    def __init__(self, palavra, chave):
        self.palavra = palavra
        self.chave = chave
    
    def encriptar(palavra, chave):
        alfabeto = 'abcdefghijklmnopqrstuvwxyz0123456789 '
    # Criei uma variavel para armazenar o texto criptografado 
        texto_criptografado = ""
        contador = 0
    # Criei uma for para armazenar o cada letra da variavel palavra(palavra do Input que o usuario vai digitar)
        for letra in palavra:

            # Criptografia: texto criptografado = palavra + chave (Alfabeto % 26 + 9 numeros) 
            soma = alfabeto.find(letra) + alfabeto.find(chave[contador % len(chave)])
            # Nessa linha de código tento encontrar a posição da letra  + a posição das letras da chave e o modulo, dessa maneira a frase escrita pelo usuario nunca superará a chave
    
            indice = int(soma) % len(alfabeto) 
            # A variavel "indice" é o nosso modulo 
            # Sigo a formula de Vigere e faço o modulo

            texto_criptografado = texto_criptografado + alfabeto[indice]
            # Aqui faço a encriptação da frase escrita 
            # Texto criptografado será o texto criptografado porém na posição especificada nos ultimos dois códigos acima
            
            contador+=1
        return texto_criptografado


# A função é a mesma, porém ao invés de somar a posição das letras + posição das letras da chave e o modulo, faço menos
    def desencriptar(palavra, chave):
        alfabeto = 'abcdefghijklmnopqrstuvwxyz0123456789 '
        texto_descriptografado = " "
        contador = 0
        for letra in palavra:

    # Descriptografia:  palavra = texto criptografado - chave (Alfabeto 26 + 9 numeros)
            menos = alfabeto.find(letra) - alfabeto.find(chave[contador % len(chave)])
            indice = menos % len(alfabeto)
            texto_descriptografado = texto_descriptografado + alfabeto[indice]
            contador+=1

        return texto_descriptografado

class Codificacao:

    def __init__(self, frase, deslocamento):
        self.frase = frase

        if deslocamento.isnumeric():
            self.deslocamento = int(deslocamento)
        else:
            raise ValueError('O valor digitado deve ser do tipo inteiro')

    def codifica_frase(self):

        frase_codificada = ''
        for caractere in frase:

            if caractere.isnumeric():
                 codigoNumero = (int(caractere) + self.deslocamento) % 10
                 frase_codificada += str(codigoNumero)

            else:
                if caractere.isalpha():
                    codigo = ord(caractere) - ord('a')
                    codigo = (codigo + self.deslocamento) % 26
                    caractere_codificado = chr(codigo + ord('a'))
                else:
                    caractere_codificado = caractere

                frase_codificada += caractere_codificado

        return frase_codificada

    def descodifica_frase(self):

        frase_descodificada = ""
        for caractere in frase:

            if caractere.isnumeric():
                 codigoNumero = (int(caractere) - self.deslocamento) % 10
                 frase_descodificada += str(codigoNumero)

            else:
                if caractere.isalpha():
                    codigo = ord(caractere) - ord('a')
                    codigo = (codigo - self.deslocamento) % 26
                    caractere_descodificado = chr(codigo + ord('a'))
                else:
                    caractere_descodificado = caractere

                frase_descodificada += caractere_descodificado

        return(frase_descodificada)

class Trilha:


    
    def __init__(self, text, key):
        self.text = text
        self.key = key

    def convertToMatrix(conString, lim):
      #enche a string com espaco pra ser um
      #fator do limit (lim)
      num_spaces = lim - len(conString) % lim
      conString += ' ' * num_spaces
      #converter a string em uma array 1D 
      arr = np.array(list(conString))

      #reshape() array para 2D com lim de colunas
      fileira = arr.reshape(-1, lim)

      return fileira

    def transpose(matrix):
      #transposta matrix usando compreencao composta
      trans = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]))]

      return trans


    def encrypt(text, key):
      global var1, transVar1
      result = []
      var1 = Trilha.convertToMatrix(text, len(key))
 
      transVar1 = Trilha.transpose(var1)

      sortedKey = sorted(key)
      rail = dict(zip(key, transVar1))

      for k in sortedKey:
        result += rail[k]

      return ''.join(result)
    
    def decrypt(text, key):
        
        hiddenTextMatrix = Trilha.convertToMatrix(text, len(key))
        sortedKey = sorted(key)
        numOrder = dict(zip(sortedKey,hiddenTextMatrix.tolist()))
        result = []
        for num in key:
             result.append(numOrder[num])
                
        newR = Trilha.transpose(result)
        plain =[]
        for line in newR:
            plain+= line
   
        
        
        return "".join(plain)

class Validacao:
  def __init__(self, frase):
    self.frase = frase
  
  def valido(frase):
    alphabeto = list(map(chr, range(ord('a'), ord('z')+1)))
    num = [number for number in range(10)]
    
    for i in frase:
      if (i in alphabeto) or (i in num):
        return True
        break
      else:
        return False

print(Validacao.valido("@"))

#                    Front-end

# Gabriel Hideki RA 195463                      1° Semetre de Sistemas da informação 
# Igor Oliveira Assis - 180413                  3° Semetre de Engenharia da computação
# Mateus Torlai dos Anjos - 195994              1° Semetre de Engenharia da computação

import streamlit as st
from streamlit_custom_notification_box import custom_notification_box as scnb

def AlertBox(wht_msg):
    styles = {'material-icons':{'color': '#F02D0E'},
            'text-icon-link-close-container': {'box-shadow': '#F02D0E 0px 4px'},
            'notification-text': {'':''},
            'close-button':{'':''},
            'link':{'':''}}

    scnb(icon='books', 
        textDisplay=wht_msg, 
        externalLink='', 
        url='#', 
        styles=styles, 
        key="foo")
def display_labels(label):
    if label == 1:
        return "Cifra de Ceasar"
    elif label == 2:
        return "Cifra de Viginère"
    elif label == 3:
        return "Cifra de Trilha"

point_e_algo = st.selectbox("Escolha a criptografia",
                            range(1, 4),
                            format_func=display_labels)

if point_e_algo == 1:
    with st.form(key="my_form"):
        help = "Insira sua mensagem"
        frase = st.text_input(help)
        help1 = "Insira a chave"
        deslocamento = st.text_input(help1)
        encode = st.form_submit_button("Codificar")
        if encode:
                cifra = Codificacao(frase, deslocamento)
                texto = cifra.codifica_frase()
                AlertBox(texto)
        decode = st.form_submit_button("Decodificar")
        if decode:
                cifra = Codificacao(frase, deslocamento)
                texto = cifra.descodifica_frase()
                AlertBox(texto)
elif point_e_algo == 2:
    with st.form(key="my_form"):
        help = "Insira sua mensagem"
        mensagem = st.text_input(help)
        help1 = "Insira a chave"
        chave = st.text_input(help1)
        encrypt = st.form_submit_button("Encriptar")
        if encrypt:
                texto = Vigenere.encriptar(mensagem, chave)
                AlertBox(texto)
        decode = st.form_submit_button("Desencriptar")
        if decode:
                texto = Vigenere.desencriptar(mensagem, chave)
                AlertBox(texto)
elif point_e_algo == 3:
    with st.form(key="my_form"):
        help = "Insira sua mensagem"
        mensagem = st.text_input(help)
        help1 = "Insira a chave"
        chave = st.text_input(help1)
        encrypt = st.form_submit_button("Encriptar")
        if encrypt:
                texto = Trilha.encrypt(mensagem, chave)
                AlertBox(texto)
        decode = st.form_submit_button("Desencriptar")
        if decode:
                texto = Trilha.decrypt(mensagem, chave)
                AlertBox(texto)
